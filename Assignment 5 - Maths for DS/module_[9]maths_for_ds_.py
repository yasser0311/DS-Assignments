# -*- coding: utf-8 -*-
"""Module - [9]Maths for DS .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ClcMTdXC49dmON3aKV1VS38A1PjxlM3G
"""

import numpy as np
from numpy.linalg import eig, inv, det, matrix_rank, norm

def main():
    # Section 1: Matrix and Vector Operations
    print("\n=== Section 1: Matrix and Vector Operations ===")

    # Create matrix A and vector B
    A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    B = np.array([1, 2, 3])

    print("\nOriginal Matrix A:")
    print(A)
    print("\nVector B:")
    print(B)

    # 1.1 Matrix-vector multiplication
    try:
        result = A @ B  # or np.matmul(A, B)
        print("\n1.1 Matrix-vector multiplication A X B:")
        print(result)
    except ValueError as e:
        print(f"\nError in matrix-vector multiplication: {e}")

    # 1.2 Trace of matrix A
    trace_A = np.trace(A)
    print("\n1.2 Trace of matrix A:", trace_A)

    # 1.3 Eigenvalues and eigenvectors
    try:
        eigenvalues, eigenvectors = eig(A)
        print("\n1.3 Eigenvalues of A:")
        print(eigenvalues)
        print("\nEigenvectors of A:")
        print(eigenvectors)
    except np.linalg.LinAlgError as e:
        print(f"\nError calculating eigenvalues/eigenvectors: {e}")

    # 1.4 Update last row of A
    A_updated = A.copy()
    A_updated[-1] = [10, 11, 12]
    print("\n1.4 Updated Matrix A (new last row):")
    print(A_updated)

    # 1.5 Determinant of updated A
    try:
        det_A = det(A_updated)
        print("\n1.5 Determinant of updated A:", det_A)
        print("Matrix is singular." if np.isclose(det_A, 0) else "Matrix is non-singular.")
    except np.linalg.LinAlgError as e:
        print(f"\nError calculating determinant: {e}")

    # Section 2: Invertibility of Matrices
    print("\n=== Section 2: Invertibility of Matrices ===")

    # 2.1 Check invertibility and calculate inverse
    try:
        if not np.isclose(det_A, 0):
            A_inv = inv(A_updated)
            print("\n2.1 Inverse of updated A:")
            print(A_inv)
        else:
            print("\n2.1 Matrix is singular (determinant = 0), no inverse exists.")
    except np.linalg.LinAlgError as e:
        print(f"\nError calculating inverse: {e}")

    # 2.2 Solve linear system A x X = B
    try:
        if not np.isclose(det_A, 0):
            solution = np.linalg.solve(A_updated, B)
            print("\n2.2 Solution to A x X = B:")
            print(solution)
        else:
            print("\n2.2 Cannot solve system - matrix is singular.")
    except np.linalg.LinAlgError as e:
        print(f"\nError solving linear system: {e}")

    # Section 3: Practical Matrix Operations
    print("\n=== Section 3: Practical Matrix Operations ===")

    # 3.1 Create random matrix C
    C = np.random.randint(1, 21, size=(4, 4))
    print("\n3.1 Random Matrix C (4x4):")
    print(C)

    # 3.1.1 Rank of C
    print("\n3.1.1 Rank of C:", matrix_rank(C))

    # 3.1.2 Submatrix of C (first 2 rows, last 2 columns)
    submatrix_C = C[:2, -2:]
    print("\n3.1.2 Submatrix of C (first 2 rows, last 2 columns):")
    print(submatrix_C)

    # 3.1.3 Frobenius norm of C
    frobenius_norm = norm(C, 'fro')
    print("\n3.1.3 Frobenius norm of C:", frobenius_norm)

    # 3.2 Matrix multiplication with A and C
    try:
        # Reshape C to 3x3 by taking first 3 rows and columns
        C_reshaped = C[:3, :3]
        print("\n3.2 Reshaped C (3x3):")
        print(C_reshaped)

        product = A_updated @ C_reshaped
        print("\nMatrix product A (updated) X C (reshaped):")
        print(product)
    except ValueError as e:
        print(f"\nError in matrix multiplication: {e}")

    # Section 4: Data Science Context
    print("\n=== Section 4: Data Science Context ===")

    # 4.1 Create dataset matrix D
    D = np.array([[3, 5, 7, 9, 11],
                 [2, 4, 6, 8, 10],
                 [1, 3, 5, 7, 9],
                 [4, 6, 8, 10, 12],
                 [5, 7, 9, 11, 13]])

    print("\n4.1 Dataset Matrix D (5x5):")
    print(D)

    # 4.1.1 Standardize D column-wise
    D_standardized = (D - D.mean(axis=0)) / D.std(axis=0)
    print("\n4.1.1 Standardized D (column-wise):")
    print(D_standardized)

    # 4.1.2 Covariance matrix
    covariance_matrix = np.cov(D_standardized, rowvar=False)
    print("\n4.1.2 Covariance matrix of standardized D:")
    print(covariance_matrix)

    # 4.1.3 PCA
    try:
        # Eigen decomposition of covariance matrix
        eigenvalues_pca, eigenvectors_pca = eig(covariance_matrix)

        print("\n4.1.3 PCA Results:")
        print("Eigenvalues:")
        print(eigenvalues_pca)
        print("\nEigenvectors (principal components):")
        print(eigenvectors_pca)

        # Sort eigenvalues and eigenvectors in descending order
        sorted_indices = np.argsort(eigenvalues_pca)[::-1]
        eigenvalues_sorted = eigenvalues_pca[sorted_indices]
        eigenvectors_sorted = eigenvectors_pca[:, sorted_indices]

        # Select top 2 principal components
        top_2_components = eigenvectors_sorted[:, :2]

        # Project data onto principal components
        D_reduced = D_standardized @ top_2_components
        print("\nReduced dataset (2 principal components):")
        print(D_reduced)
    except np.linalg.LinAlgError as e:
        print(f"\nError performing PCA: {e}")

if __name__ == "__main__":
    main()